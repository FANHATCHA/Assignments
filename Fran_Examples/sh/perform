#! /bin/sh

#			perform: perform an execution of a group of files with output
#					 sent to a group of files with names generated from
#					 the source group names
#
#			Andrew Hamilton-Wright		Jun 93
#
#			slightly improved version -- handles bad cases a little better
#
# $Id: perform 150 2011-01-03 14:51:46Z andrew $
#
count=0					# initialize counter to skip valid args
operator=" "			# initialize redirection operator to null
trstr="cat"				# default value if no case change
page=" "
if [ $# -gt 0 ]
then
		for file in "$@"
		do
			case "$file" in
			-h*)		{		# print help
					echo " perform -c<cmd> -s</RE/rep/> [-o<OP>] [-p] [-lc] [-uc] <file> . . . "
					echo " "
					echo " perform executes a command <cmd> on all <files> while directing output"
					echo " (through operator <OP>, where <OP> is '\>', '\>\>' or '\<'), to a group"
					echo " of files whose names are generated by using the <RE> to search/replace"
					echo " within the source file names."
					echo " "
					echo " NOTE: while RE is a standard regexp, some characters (eg $,>,<,&) have to"
					echo " be preceeded by a '\' to escape shell processing."
					echo " "
					echo " -lc will force output filename into lowercase, &"
					echo " -uc will force uppercase"
					echo " -p  will 'page' - actally about 6 lines between performs"
					echo " "
					echo " Example:  this will move all .c files to .cpp"
					echo " "
					echo " perform -cmv -s/.c\\\$/.cpp/ *.c"
					echo " "
					} ;;

			-o*)		{		# use a redirection operator
					temp=`echo "$file" | cut -c3- `
					case $temp in
						\>\>*)		{ operator=">>"
									  opflag="3"
									} ;;
						\>*)		{ operator=">"
									  opflag="1"
									} ;;
						\<*)		{ operator="<"
									  opflag="2"
									} ;;
						*)				{ operator=" " 
									  opflag="0"
									} ;;
					esac
					} ;;

			-p*)		{		# print a big break between performs
					page="\n.\n\n.\n\n.\n\n"
					} ;;

			-c*)		{		# save command to run
					cmd=`echo "$file" | cut -c3- `
					count=$(( $count + 1 ))
										# set bitflag for validity test
					} ;;

			-s*)		{		# save search/replace string to run on sed
					sedstr=`echo "$file" | cut -c3- `
					count=$(( $count + 2 ))		# set other bitflag
					} ;;
			-uc*)		{
			trstr="tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ"
					} ;;

			-lc*)		{
			trstr="tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz"
					} ;;

			*)		{		# process a filename
					if [ $count -ge 3 ]
					then		# it is valid
							# this is actually the heart of the routine,
							# everything else is just pretty
						if
							newfile=`echo "$file" | sed "s$sedstr" | "$trstr"`
							if [ "$newfile" = "$file" ]
							then
								echo "perform: sed failure - source & dest filenames are identical ($file $newfile)"
								exit 1
							fi

							echo " $page performing: $cmd \"$file\" $operator \"$newfile\"  "

							case $opflag in
							1*)		{
									$cmd "$file" > "$newfile" ;
									} ;;
							2*)		{
									$cmd "$file" < "$newfile" ;
									} ;;
							3*)		{
									$cmd "$file" >> "$newfile" ;
									} ;;
							*)		{
									$cmd "$file" "$newfile" ;
									} ;;
							esac
									# this is the actual meat of the prog -
									# for some reason, the shell has
									# trouble recognizing the redirection
									# operators if they come out of a var
						then
							sleep 0
						else
							echo "perform: bad command exit status "
						fi

					else		# we are missing a flag
					
						if [ $(( $count % 2 )) -eq 0 ]
						then		# bit 1 not set
							echo "perform: no command given "
						fi
						if [ $(( $count / 2 % 2 )) -eq 0 ]
						then		# bit 2 not set
							echo "perform: no match pattern given "
						fi
						exit 1
					fi
					} ;;
			esac
		done
else
		echo
		echo " perform -c<cmd> -s</RE/rep/> [-o<OP>] [-lc] [-uc] <file> . . . "
		echo
		echo " perform -h for verbose help "
		echo
		echo
fi
